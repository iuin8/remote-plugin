package io.github.iuin8.remote

import java.io.File
import java.util.concurrent.TimeUnit
import java.io.InputStreamReader
import java.nio.charset.StandardCharsets

/**
 * SSH 配置和密钥自动设置管理器
 * 负责自动生成配置文件、密钥对，以及修复私钥文件权限
 */
object SshSetupManager {
    
    /**
     * 设置项目的 SSH 配置
     * 主入口方法，协调所有 SSH 相关的自动化设置
     * 
     * @param projectRootDir 项目根目录
     */
    fun setupProjectSsh(projectRootDir: File) {
        try {
            println("[remote-plugin] 正在初始化项目配置...")
            
            // 第一步：生成配置文件
            generateConfigFiles(projectRootDir)
            
            // 第二步：修复私钥权限
            fixPrivateKeyPermissions(projectRootDir)
            
            println("[remote-plugin] 配置初始化完成，请根据实际情况修改 remote.yml")
            
            // 添加完成提示
            if (RemotePluginUtils.isWindows()) {
                println("[remote-plugin] 检测到 Windows 系统，跳过权限检查")
                println("[remote-plugin] 配置文件检查完成")
            }
            
        } catch (e: Exception) {
            println("[remote-plugin] [WARN] SSH 配置初始化过程中出现异常：${e.message}")
        }
    }
    
    /**
     * 生成配置文件（remote.yml 和 .ssh/config）
     */
    private fun generateConfigFiles(projectRootDir: File) {
        val remotePluginDir = File(projectRootDir, "gradle/remote-plugin")
        val sshDir = File(remotePluginDir, ".ssh")
        
        // 生成 remote.yml
        generateRemoteYml(remotePluginDir)
        
        // 生成 .ssh/config
        generateSshConfig(sshDir)
        
        // 根据配置决定是否生成密钥
        generateSshKeyPairIfNeeded(projectRootDir, sshDir)
    }
    
    /**
     * 根据配置决定是否生成 SSH 密钥对
     */
    private fun generateSshKeyPairIfNeeded(projectRootDir: File, sshDir: File) {
        // 读取 remote.yml 配置
        val remoteYmlFile = File(projectRootDir, "gradle/remote-plugin/remote.yml")
        
        // 默认不自动生成密钥
        var autoKeygen = false
        
        if (remoteYmlFile.exists()) {
            try {
                val parsedConfig = ConfigMerger.parseSimpleYamlWithBase(remoteYmlFile)
                val baseConfig = parsedConfig.commonConfigs["base"] ?: emptyMap()
                autoKeygen = baseConfig["ssh.setup.auto.keygen"]?.toBoolean() ?: false
            } catch (e: Exception) {
                println("[remote-plugin] [WARN] 解析 remote.yml 配置时出错: ${e.message}")
            }
        }
        
        // 如果未启用自动密钥生成，提示用户
        if (!autoKeygen) {
            println("[remote-plugin] ℹ 密钥自动生成已禁用（默认）")
            println("[remote-plugin] 提示：如需自动生成密钥，请在 remote.yml 中设置 ssh.setup.auto.keygen: true")
            return
        }
        
        // 检查是否已有私钥
        if (hasPrivateKey(sshDir)) {
            return
        }
        
        // 生成密钥对
        generateSshKeyPair(sshDir)
    }
    
    /**
     * 检查 .ssh 目录下是否已有私钥
     */
    private fun hasPrivateKey(sshDir: File): Boolean {
        if (!sshDir.exists() || !sshDir.isDirectory) {
            return false
        }
        
        return sshDir.listFiles()?.any { file ->
            file.isFile && isPrivateKeyFile(file)
        } ?: false
    }
    
    /**
     * 生成 SSH 密钥对
     */
    private fun generateSshKeyPair(sshDir: File) {
        try {
            // 确保 .ssh 目录存在
            sshDir.mkdirs()
            
            // 检查 ssh-keygen 命令是否存在
            val process = Runtime.getRuntime().exec(arrayOf("which", "ssh-keygen"))
            val exitCode = process.waitFor()
            
            if (exitCode != 0) {
                println("[remote-plugin] [WARN] 系统中未找到 ssh-keygen 命令，跳过密钥生成")
                return
            }
            
            val privateKeyFile = File(sshDir, "id_ed25519")
            
            // 生成 Ed25519 密钥对
            val command = arrayOf(
                "ssh-keygen",
                "-t", "ed25519",
                "-f", privateKeyFile.absolutePath,
                "-N", "",  // 空密码
                "-C", "Generated by Gradle Remote Plugin"
            )
            
            val keygenProcess = Runtime.getRuntime().exec(command)
            val keygenExitCode = keygenProcess.waitFor()
            
            if (keygenExitCode == 0) {
                // 设置私钥文件权限为 600
                if (!RemotePluginUtils.isWindows()) {
                    setFilePermissions(privateKeyFile, true, true, false)
                }
                
                println("[remote-plugin] ✓ 已生成 SSH 密钥对 (Ed25519)")
                println("[remote-plugin]   私钥: ${privateKeyFile.relativeTo(sshDir.parentFile.parentFile.parentFile).path}")
                println("[remote-plugin]   公钥: ${File(privateKeyFile.absolutePath + ".pub").relativeTo(sshDir.parentFile.parentFile.parentFile).path}")
                
                if (!RemotePluginUtils.isWindows()) {
                    println("[remote-plugin] ✓ 已设置私钥权限 (600)")
                }
            } else {
                println("[remote-plugin] [WARN] 生成 SSH 密钥对失败")
                // 读取错误输出
                keygenProcess.errorStream.bufferedReader().use { reader ->
                    val errorOutput = reader.readText()
                    if (errorOutput.isNotBlank()) {
                        println("[remote-plugin] [WARN] 错误信息: $errorOutput")
                    }
                }
            }
        } catch (e: Exception) {
            println("[remote-plugin] [WARN] 生成 SSH 密钥对时出现异常: ${e.message}")
        }
    }
    
    /**
     * 生成 remote.yml 配置文件
     */
    private fun generateRemoteYml(remotePluginDir: File) {
        val remoteYmlFile = File(remotePluginDir, "remote.yml")
        
        if (remoteYmlFile.exists()) {
            return
        }
        
        try {
            remotePluginDir.mkdirs()
            remoteYmlFile.writeText(loadTemplateFromResource("templates/remote-plugin/remote.yml.template"))
            println("[remote-plugin] ✓ 已生成 remote.yml 配置模板")
        } catch (e: Exception) {
            println("[remote-plugin] [WARN] 无法生成 remote.yml: ${e.message}")
        }
    }
    
    /**
     * 生成 .ssh/config 配置文件
     */
    private fun generateSshConfig(sshDir: File) {
        val configFile = File(sshDir, "config.template")
        
        if (configFile.exists()) {
            return
        }
        
        try {
            sshDir.mkdirs()
            // 设置 .ssh 目录权限为 700
            if (!RemotePluginUtils.isWindows()) {
                setFilePermissions(sshDir, true, true, true)
            }
            
            configFile.writeText(loadTemplateFromResource("templates/remote-plugin/.ssh/config.template"))
            
            // 设置 config 文件权限为 600
            if (!RemotePluginUtils.isWindows()) {
                setFilePermissions(configFile, true, true, false)
            }
            
            println("[remote-plugin] ✓ 已生成 .ssh/config.template 配置模板")
        } catch (e: Exception) {
            println("[remote-plugin] [WARN] 无法生成 .ssh/config.template: ${e.message}")
        }
    }
    
    /**
     * 修复私钥文件权限
     */
    private fun fixPrivateKeyPermissions(projectRootDir: File) {
        val sshDir = File(projectRootDir, "gradle/remote-plugin/.ssh")
        
        if (!sshDir.exists() || !sshDir.isDirectory) {
            return
        }
        
        // 修复 .ssh 目录权限
        if (!RemotePluginUtils.isWindows()) {
            if (setFilePermissions(sshDir, true, true, true)) {
                // println("[remote-plugin] ✓ 已修复 .ssh 目录权限为 700")
            } else {
                println("[remote-plugin] [WARN] 无法修复 .ssh 目录权限")
            }
        }
        
        // 扫描并修复私钥文件权限
        val privateKeyFiles = mutableListOf<File>()
        
        sshDir.listFiles()?.forEach { file ->
            if (file.isFile && isPrivateKeyFile(file)) {
                privateKeyFiles.add(file)
            }
        }
        
        if (privateKeyFiles.isEmpty()) {
            return
        }
        
        println("[remote-plugin] 检查 SSH 私钥文件权限...")
        println("[remote-plugin] 找到 ${privateKeyFiles.size} 个私钥文件")
        
        var fixedCount = 0
        
        privateKeyFiles.forEach { file ->
            // 检查当前权限
            if (RemotePluginUtils.isWindows()) {
                println("[remote-plugin] ✓ ${file.name} - Windows 系统跳过权限检查")
                return@forEach
            }
            
            // 简单检查权限（注意：Java 的 canRead/Writable/Execute 不精确反映 Unix 权限）
            // 这里我们直接尝试修复权限
            if (setFilePermissions(file, true, true, false)) {
                println("[remote-plugin] ✓ ${file.name} - 已修复权限 (600)")
                fixedCount++
            } else {
                println("[remote-plugin] ⚠ 无法修复私钥权限：${file.name} (权限不足)")
                println("[remote-plugin] 建议手动执行：chmod 600 ${file.absolutePath}")
            }
        }
        
        println("[remote-plugin] SSH 私钥权限检查完成")
    }
    
    /**
     * 判断文件是否为私钥文件
     * 采用文件名初筛 + 内容检测的方式
     */
    private fun isPrivateKeyFile(file: File): Boolean {
        // 第一阶段：文件名初筛
        if (!matchesPrivateKeyFileName(file.name)) {
            return false
        }
        
        // 第二阶段：内容检测
        return containsPrivateKeyMarker(file)
    }
    
    /**
     * 检查文件名是否符合私钥文件特征
     */
    private fun matchesPrivateKeyFileName(fileName: String): Boolean {
        // 快速排除明显不是私钥的文件
        if (fileName.contains(".pub") || fileName.contains("public")) {
            return false
        }
        
        if (fileName == "config" || fileName == "known_hosts" || fileName == "authorized_keys") {
            return false
        }
        
        // 可能是私钥的文件
        return fileName == "id_rsa" || 
               fileName == "id_dsa" || 
               fileName == "id_ecdsa" || 
               fileName == "id_ed25519" ||
               fileName.startsWith("id_rsa_") ||
               fileName.startsWith("id_dsa_") ||
               fileName.startsWith("id_ecdsa_") ||
               fileName.startsWith("id_ed25519_") ||
               fileName.endsWith(".pem") ||
               fileName.endsWith(".key") ||
               (fileName.contains("private") && !fileName.contains(".pub"))
    }
    
    /**
     * 检测文件内容是否包含私钥标识
     * 读取第一个非空行，检查是否包含 PRIVATE KEY
     */
    private fun containsPrivateKeyMarker(file: File): Boolean {
        return try {
            file.bufferedReader().use { reader ->
                reader.lineSequence()
                    .firstOrNull { line -> line.isNotBlank() }
                    ?.contains("PRIVATE KEY")
                    ?: false
            }
        } catch (e: Exception) {
            // 读取失败时降级为文件名判断
            false
        }
    }
    

    

    
    /**
     * 从资源文件加载模板内容
     */
    private fun loadTemplateFromResource(resourceName: String): String {
        return this::class.java.classLoader.getResourceAsStream(resourceName)?.use { inputStream ->
            InputStreamReader(inputStream, StandardCharsets.UTF_8).readText()
        } ?: throw IllegalStateException("无法加载资源文件: $resourceName")
    }
    
    /**
     * 检测是否为 Windows 系统
     */
    
    /**
     * 设置文件权限（Unix/Linux/macOS）
     * 
     * @param file 目标文件
     * @param ownerReadable 所有者可读
     * @param ownerWritable 所有者可写
     * @param ownerExecutable 所有者可执行
     * @param othersReadable 其他人可读
     * @param othersWritable 其他人可写
     * @param othersExecutable 其他人可执行
     */
    private fun setFilePermissions(
        file: File,
        ownerReadable: Boolean,
        ownerWritable: Boolean,
        ownerExecutable: Boolean,
        othersReadable: Boolean = false,
        othersWritable: Boolean = false,
        othersExecutable: Boolean = false
    ): Boolean {
        return try {
            file.setReadable(othersReadable, false)
            file.setReadable(ownerReadable, true)
            file.setWritable(othersWritable, false)
            file.setWritable(ownerWritable, true)
            file.setExecutable(othersExecutable, false)
            file.setExecutable(ownerExecutable, true)
            true
        } catch (e: Exception) {
            false
        }
    }
    
}